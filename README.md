# RTL_Design_and_Synthesis
---

## Day 1 ‚Äì Introduction to Verilog RTL Design and Synthesis

## Getting Started with the Open-Source Simulator: Icarus Verilog (iverilog)

A **simulator** is a tool used to verify whether a digital design behaves according to its specifications. In RTL (Register Transfer Level) design, simulation helps confirm that the logic works correctly by applying various input conditions and observing the outputs.

For this course, we will use **Icarus Verilog (iverilog)**‚Äîan open-source Verilog simulation tool.

### What is a Design?

A *design* refers to the Verilog code or a set of modules written in Verilog that describe the desired hardware functionality according to the given specifications.

### What is a Test Bench?

A *test bench* is a setup used to verify the design. It provides the necessary input signals (also known as test vectors) and checks the resulting outputs. The test bench mimics a real-world environment to ensure the design functions as expected.

** How Does a Simulator Work?

The simulator operates by monitoring changes in input signals.

* When an input changes, it triggers the simulator to evaluate and update the corresponding outputs.
* If there is no input change, the outputs remain the same.

This *event-driven* approach ensures efficient simulation by responding only to signal transitions.

### Design and Test Bench Structure

* The **design** includes one or more *primary inputs* and *primary outputs*.
* The **test bench** includes:

  * A **stimulus generator** to apply inputs to the design.
  * A **stimulus observer** to monitor and verify the outputs.

Together, these components create a simulation environment where the test bench interacts with the design.

> **Note:** The test bench itself does not have any primary inputs or outputs. It functions entirely within the simulation environment and is not part of the synthesized hardware.


<img width="831" height="394" alt="Screenshot 2025-08-04 at 7 19 57‚ÄØPM" src="https://github.com/user-attachments/assets/4489e1dc-ca90-4ce6-9793-c76921c81c88" />



Iverilog-based simulation flow:

The design and test bench are provided as inputs to iverilog. As mentioned earlier, the simulator monitors changes in input signals and updates the output accordingly. The output generated by the simulator is a .vcd file, which stands for Value Change Dump format.

To view this output waveform, we use GTKWave.


<img width="832" height="375" alt="Screenshot 2025-08-04 at 7 20 17‚ÄØPM" src="https://github.com/user-attachments/assets/784b4edf-70eb-4033-aba6-116ade6a6e68" />



### **Labs Using Icarus Verilog and GTKWave**

**SKY130RTL D1SK2 L1 ‚Äì Lab 1: Introduction to the Lab**

---

### **Toolflow and File Setup for Lab Exercises**

To begin working on the labs, you'll need to set up the appropriate toolchain and directory structure.

---

#### **Step 1: Create a Project Directory**

Start by creating a directory to hold all lab-related files, and navigate into it:

```bash
mkdir VLSI
cd VLSI
```

---

#### **Step 2: Clone Required GitHub Repositories**

Next, clone the necessary repositories that contain lab content and support files:

1. **sky130RTLDesignAndSynthesisWorkshop** ‚Äì Contains the RTL design and synthesis labs

```bash
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
```

2. **vsdflow** ‚Äì Contains the helper scripts and flow setup for simulations

```bash
git clone https://github.com/kunalg123/vsdflow.git
```

---

#### **Directory Structure After Setup**

Once the cloning is complete, your folder structure will be:

```
VLSI/
‚îú‚îÄ‚îÄ sky130RTLDesignAndSynthesisWorkshop/
‚îî‚îÄ‚îÄ vsdflow/
```

You are now ready to start with the lab exercises using **Icarus Verilog (iverilog)** for simulation and **GTKWave** for waveform visualization.


<img width="826" height="407" alt="Screenshot 2025-08-04 at 7 25 09‚ÄØPM" src="https://github.com/user-attachments/assets/1fa040e9-5106-4b63-91e4-57a8923fb52e" />


<img width="829" height="390" alt="Screenshot 2025-08-04 at 7 25 17‚ÄØPM" src="https://github.com/user-attachments/assets/fae477c7-3dbe-4f78-9dd6-aee1e77ab2e8" />



---

### **Lab 2 ‚Äì Introduction to Icarus Verilog and GTKWave (Part 1)**

**Tool Installation Guide**

To run the simulation labs successfully, you need to install the following tools:

---

#### **1. Install Icarus Verilog (iverilog)**

Icarus Verilog is a compiler and simulator for Verilog HDL.

Use the following command in the terminal to install:

```bash
sudo apt-get install iverilog
```

---

#### **2. Install GTKWave**

GTKWave is a waveform viewer used to visualize simulation outputs.

Install it with:

```bash
sudo apt-get install gtkwave
```

---

Once installed, these tools will enable you to:

* **Compile and simulate** your Verilog designs using `iverilog`
* **View and analyze** signal waveforms using `gtkwave`



![WhatsApp Image 2025-08-04 at 19 31 31 (1)](https://github.com/user-attachments/assets/3605abcf-d004-4485-9c1a-f5910d36be78)


![WhatsApp Image 2025-08-04 at 19 31 32 (1)](https://github.com/user-attachments/assets/51b75556-ebeb-4df2-a634-5f75b512b8ae)


![WhatsApp Image 2025-08-04 at 19 31 31](https://github.com/user-attachments/assets/238e0dbe-b689-432c-b2b2-2f23c6390355)


![WhatsApp Image 2025-08-04 at 19 31 32 (2)](https://github.com/user-attachments/assets/6083af95-f11d-405e-a2cf-9fbf9082c780)



---

## **Lab 2 ‚Äì Part 2: Simulating and Visualizing `good_mux` Design**

### **1. Verilog Design File: `good_mux.v`**

```verilog
module good_mux (input i0, input i1, input sel, output reg y);

  always @(*) begin
    if (sel)
      y = i1;
    else
      y = i0;
  end

endmodule
```

#### üîç **Explanation:**

* **Inputs:** `i0`, `i1`, `sel` ‚Äì all are 1-bit signals.
* **Output:** `y` ‚Äì 1-bit output declared as `reg` because it is assigned inside an `always` block.
* **Functionality:** Implements a **2:1 multiplexer**.

  * If `sel = 1`, then `y = i1`.
  * If `sel = 0`, then `y = i0`.
* The `always @(*)` block ensures the logic is sensitive to all input changes.

---

### **2. Testbench File: `tb_good_mux.v`**

```verilog
`timescale 1ns / 1ps

module tb_good_mux;

  // Inputs
  reg i0, i1, sel;

  // Output
  wire y;

  // Instantiate the Unit Under Test (UUT)
  good_mux uut (
    .i0(i0),
    .i1(i1),
    .sel(sel),
    .y(y)
  );

  initial begin
    $dumpfile("tb_good_mux.vcd");      // Dump file for GTKWave
    $dumpvars(0, tb_good_mux);         // Record all variables under tb_good_mux

    // Initialize Inputs
    sel = 0;
    i0 = 0;
    i1 = 0;

    // Run simulation for 300 ns
    #300 $finish;
  end

  // Toggle sel every 75 ns
  always #75 sel = ~sel;

  // Toggle i0 every 10 ns
  always #10 i0 = ~i0;

  // Toggle i1 every 55 ns
  always #55 i1 = ~i1;

endmodule
```

---

### **üî¨ Testbench Behavior Summary:**

* **Simulation Time:** 300 ns total
* **Signal Toggles:**

  * `sel` toggles every 75 ns ‚Üí switches MUX input selection.
  * `i0` toggles every 10 ns.
  * `i1` toggles every 55 ns.
* **Expected Behavior:**

  * Output `y` follows either `i0` or `i1` depending on the value of `sel`.
* **Waveform Output:**

  * Stored in `tb_good_mux.vcd`
  * Can be viewed using GTKWave:

    ```bash
    gtkwave tb_good_mux.vcd
    ```

---
## Introduction to Yosys and Logic synthesis

## SKY130RTL D1SK3 L1 Introduction to yosys

Introduction to Yosys
Yosys is the synthesizer tool used in this course. It is responsible for converting RTL (Register Transfer Level) code into a gate-level netlist using standard cells.

Role of Synthesizer:
A synthesizer takes a digital RTL design and a standard cell library (.lib file) and generates a netlist that represents the circuit using gates and cells from the library.

Yosys Synthesis Flow:
Inputs to Yosys:

The RTL design (.v file)
The standard cell library (.lib file)

<img width="834" height="239" alt="Screenshot 2025-08-04 at 7 37 37‚ÄØPM" src="https://github.com/user-attachments/assets/f992e81f-9edf-4d6f-a391-4053d8548694" />

Yosys Commands:

read_verilog ‚Äì Reads the Verilog design file.
read_liberty ‚Äì Reads the .lib file containing timing and cell information.
write_verilog ‚Äì Writes out the synthesized netlist.


<img width="827" height="435" alt="Screenshot 2025-08-04 at 7 37 48‚ÄØPM" src="https://github.com/user-attachments/assets/dd43062d-c272-4f8f-b6b5-b09f8727e5c0" />

Output:

A netlist file representing the design using standard cells from the .lib library.
Netlist Verification:
To verify if the synthesis process was successful and functionally correct:

Use the same testbench that was used for the original RTL simulation.
Apply the synthesized netlist and the testbench to the simulator (Icarus Verilog).
Generate the VCD (.vcd) file.
Load the VCD file in GTKWave and compare the waveform output.


<img width="834" height="393" alt="Screenshot 2025-08-04 at 7 41 19‚ÄØPM" src="https://github.com/user-attachments/assets/5e2cbc77-e89c-43d1-b89c-c10b6c91cbeb" />


Important Notes:

The stimulus in the testbench must match the one used during RTL simulation.
The primary inputs and outputs of the netlist remain the same as the RTL design.
Therefore, the same testbench can be reused for post-synthesis simulation.


<img width="830" height="450" alt="Screenshot 2025-08-04 at 7 41 50‚ÄØPM" src="https://github.com/user-attachments/assets/259affc8-2643-4feb-9c52-5462de15f019" />



---

## **SKY130RTL D1SK3 L2 ‚Äì Introduction to Logic Synthesis (Part 1)**

### **Logic Synthesis Overview**

---

### **1. RTL Design**

RTL (Register Transfer Level) design is the behavioral representation of a digital system based on its required specification.
It defines how data moves between registers and how operations are performed on that data.


<img width="829" height="765" alt="Screenshot 2025-08-04 at 7 43 08‚ÄØPM" src="https://github.com/user-attachments/assets/45e371c8-4ce7-41fd-a651-598d2808dab8" />


<img width="828" height="582" alt="Screenshot 2025-08-04 at 7 43 16‚ÄØPM" src="https://github.com/user-attachments/assets/b7047c1c-9f9f-47a3-8fd1-24d8d654c293" />


---

### **2. What is Logic Synthesis?**

Logic synthesis is the process of converting RTL code into a digital logic circuit.
This involves translating behavioral descriptions into a network of logic gates.
The transition from RTL to gate-level design is called synthesis.
The final output of this process is a netlist, which describes the gates and their interconnections.

---

### **3. Inputs and Outputs of Synthesis**

**Inputs:**

* RTL Design (written in Verilog or VHDL)
* Technology Library (.lib file)

**Output:**

* Gate-level netlist (.v file)

### **4. What is a .lib File?**

A `.lib` file is a collection of logic cells provided by a standard cell library.

It includes basic gates like AND, OR, NOT, and their variants:

* Different input configurations (e.g., 2-input OR, 3-input OR)
* Different speed-power tradeoffs (e.g., slow, medium, fast cells)

### ***5. Why Different Flavours of Gates?***
The combinational delay in a logic path directly affects the maximum speed of a digital circuit.

<img width="825" height="366" alt="Screenshot 2025-08-04 at 7 50 04‚ÄØPM" src="https://github.com/user-attachments/assets/6fbaebb5-27e3-4638-889e-329ff7750f83" />


### **Clock Cycle Constraint**

The clock cycle must satisfy the following condition:

```
Tclk > Tcq_A + Tcomb + Tsetup_B
```

Where:

* **Tcq\_A** = Clock-to-Q delay of DFF A
* **Tcomb** = Delay of the combinational logic
* **Tsetup\_B** = Setup time of DFF B

To minimize **Tcomb**, faster cells from the `.lib` file are used.
This reduces the required clock period (**Tclk**) and increases the operating frequency.

---

### **6. Maximum Clock Frequency**

The minimum clock period defines the maximum frequency:

```
fclk(max) = 1 / Tclk(min)
```

<img width="832" height="273" alt="Screenshot 2025-08-04 at 7 50 22‚ÄØPM" src="https://github.com/user-attachments/assets/dbd1e0ce-aff0-4e06-9dc4-8a0614d30883" />

### **SKY130RTL D1SK3 L3 ‚Äì Introduction to Logic Synthesis (Part 2)**

---

### **Are Faster Cells Sufficient?**

At first glance, it might seem that using only faster cells is the key to achieving maximum performance.
After all, higher clock speeds typically mean better performance.
But this leads to an important question:

**If faster cells minimize delay, why are slower cells needed at all?**

---

### **Why Do We Need Slow Cells?**

To meet timing constraints, both **setup** and **hold** times must be satisfied:

* For **setup time** (performance constraint), data must arrive **before** the clock edge.
* For **hold time** (reliability constraint), data must remain **stable briefly after** the clock edge.



<img width="831" height="261" alt="Screenshot 2025-08-04 at 7 51 54‚ÄØPM" src="https://github.com/user-attachments/assets/2ef45725-7cf3-4f8d-9df7-3474e9408dc2" />

---

### **If the Combinational Delay is Too Short**

Hold time may be violated if:

```
Thold_B < Tcq_A + Tcomb
```

Therefore:

* **Faster cells** help reduce `Tcomb` to meet **setup timing**.
* **Slower cells** help increase `Tcomb` to prevent **hold time violations**.

The `.lib` file provides both types of cells to offer flexibility in timing closure.

---

### **Understanding Hold Time**

Hold time is the **minimum time** after a clock edge during which the input must remain **stable**.

* If data at flip-flop B changes too quickly, it may capture **incorrect data**.
* **Slower cells** introduce delay to help satisfy hold time constraints.

---

### **Faster vs. Slower Cells**

| **Parameter**    | **Faster Cells**      | **Slower Cells**          |
| ---------------- | --------------------- | ------------------------- |
| Transistor Width | Wider (more current)  | Narrower (less current)   |
| Delay            | Lower                 | Higher                    |
| Area             | Larger                | Smaller                   |
| Power            | Higher                | Lower                     |
| Use Case         | Improves setup timing | Helps fix hold violations |

---

### **Trade-Offs: Speed vs. Area/Power**

* **Faster cells**: Improve performance, but increase **area**, **power**, and **risk of hold violations**.
* **Slower cells**: Save power and area, and help with **hold timing**, but may **fail setup timing**.

---

### **Cell Selection: Guided by Constraints**

The synthesis tool selects cells, but we guide it using constraints:

* **Too many fast cells** ‚Üí High power, large area, hold issues
* **Too many slow cells** ‚Üí Fails setup timing

**Constraints include:**

* Timing (clock period, setup/hold margins)
* Area and power limits
* Design goals and trade-offs

---

### **Conclusion**

Synthesis is not just about functionality‚Äîit‚Äôs about **efficiency**.
Choosing between faster and slower cells is a critical trade-off, handled by synthesis tools using design constraints.


<img width="831" height="601" alt="Screenshot 2025-08-04 at 7 53 11‚ÄØPM" src="https://github.com/user-attachments/assets/7f334287-feb1-4431-b713-7bd257a1f3ea" />

---

## **Labs Using Yosys and SKY130 PDKs**

### **Lab 3: Yosys ‚Äì Part 1 (good\_mux)**

### **Introduction to Synthesizer: Yosys**

**Yosys** is an open-source synthesis tool used to convert RTL code into a gate-level netlist using a specified standard cell library.

---

### **Steps to Invoke and Use Yosys**

#### **Step 1: Start Yosys**

Open a terminal and navigate to your working directory:

```bash
cd verilog_files
```

Start Yosys by typing:

```bash
yosys
```

---

#### **Step 2: Read the Standard Cell Library**

Yosys must load the standard cells before synthesis. Use the following command:

```tcl
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```

---

#### **Step 3: Read the Verilog Design**

Load your RTL design file (e.g., `good_mux.v`) with:

```tcl
read_verilog good_mux.v
```

![WhatsApp Image 2025-08-04 at 19 58 30 (1)](https://github.com/user-attachments/assets/eecddd99-57ca-45d2-9c57-9ef1c17831a0)


![WhatsApp Image 2025-08-04 at 19 58 31](https://github.com/user-attachments/assets/65d8a5e1-a9b5-422c-b48b-fffea0433f22)



![WhatsApp Image 2025-08-04 at 19 58 31 (1)](https://github.com/user-attachments/assets/4cdbf5c2-cb1b-4fd1-a79d-9a321c0d31de)


3. Perform Synthesis
Specify the top module of the design:

synth -top good_mux


![WhatsApp Image 2025-08-04 at 19 58 31 (2)](https://github.com/user-attachments/assets/3b357c7c-859a-46af-b4bf-e7f25b578511)

![WhatsApp Image 2025-08-04 at 19 58 31 (3)](https://github.com/user-attachments/assets/14f8f6e3-b404-479a-bc9a-be22e1854d83)


4. Technology Mapping
Map the synthesized design to standard cells defined in the .lib file:

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

![WhatsApp Image 2025-08-04 at 19 58 31 (6)](https://github.com/user-attachments/assets/5edd8efa-bb9d-4a3b-bec4-68fe68cc5fb1)


At this stage, the synthesis is complete and the result is a netlist using specific standard cells.

5. Analyze the Output

![WhatsApp Image 2025-08-04 at 19 58 31 (7)](https://github.com/user-attachments/assets/7e6893fe-145b-4984-81db-05bec8ee0d0c)


---

### **Compare the Netlist with the Original `good_mux.v`**

**Note:**

* The synthesized netlist will not show internal signals.
* Only the 3 inputs and 1 output are retained, matching the original RTL design.
* The standard cell used is: `mux2_1`.

---

### **Visualize the Logic**

To view a graphical representation of the synthesized circuit, use the following command in Yosys:

```tcl
show
```


![WhatsApp Image 2025-08-04 at 19 58 30](https://github.com/user-attachments/assets/2b4940fb-c729-4e0a-a560-f63662bb28c1)

## **SKY130RTL D1SK4 L2 Lab3 Yosys 1 good mux Part2**

Corresponding Verilog Code

![WhatsApp Image 2025-08-04 at 19 58 31 (5)](https://github.com/user-attachments/assets/bf1c3690-e5e6-4767-96d7-52ca2c1a27dd)

---

### **Explanation of the Yosys Output Image**

The image generated using the `show` command in Yosys represents the **gate-level implementation** of the `good_mux` module, synthesized using the **Sky130** standard cell library.

---

### **Block-by-Block Explanation**

| **Element**               | **Description**                                             |
| ------------------------- | ----------------------------------------------------------- |
| `i0`, `i1`, `sel`         | Input signals entering from the left.                       |
| `$86`                     | Internal instance name automatically generated by Yosys.    |
| `sky130_fd_sc_hd__mux2_1` | 2:1 multiplexer standard cell from the Sky130 library.      |
| `A0`, `A1`, `S`           | Inputs to the multiplexer: `A0 = i0`, `A1 = i1`, `S = sel`. |
| `X`                       | Output of the multiplexer.                                  |
| `y`                       | Final output of the module, connected to the mux output.    |
| `good_mux`                | Name of the top-level RTL module.                           |

---

### **Mapping Between RTL and Synthesized Logic**

* The RTL `always` block uses an `if-else` condition to assign `y` based on `sel`.
* Yosys recognizes this as a **2:1 multiplexer** during synthesis.
* It replaces the behavioral logic with a `sky130_fd_sc_hd__mux2_1` cell.
* This cell has inputs `A0`, `A1`, and `S`, and one output `X` which drives `y`.

---

### **Conclusion**

Yosys has successfully:

* Synthesized the RTL to a **gate-level netlist**.
* Mapped the logic to a **Sky130 multiplexer cell**.
* Optimized internal signals into direct standard cell connections.

---

### **Writing the Netlist in Yosys**

After synthesis and technology mapping, export the netlist using:

```tcl
write_verilog good_mux_netlist.v
```

This saves the synthesized gate-level design to `good_mux_netlist.v`.

Let me know if you‚Äôd like to continue with simulation of the netlist or preparing it for physical design.

![WhatsApp Image 2025-08-04 at 20 11 45 (1)](https://github.com/user-attachments/assets/9cda7b3b-eb3c-4d63-a713-bba457ad7d6e)

---

### **Generating the Netlist**

By default, Yosys generates a netlist file named:

```
good_mux_netlist.v
```

---

### **Creating a Simplified Netlist**

To generate a cleaner version of the netlist‚Äîexcluding attributes like timing, area, etc.‚Äîuse:

```tcl
write_verilog -noattr good_mux_netlist.v
```

This version is easier to read and focuses only on the **structural connections** in the design.


![WhatsApp Image 2025-08-04 at 20 11 45](https://github.com/user-attachments/assets/187fe4e6-5f33-4a0b-bc89-930c62ac408f)


![WhatsApp Image 2025-08-04 at 20 11 45 (2)](https://github.com/user-attachments/assets/61601c9e-a4fa-4394-8f86-c4bb5fe1f2f4)

![WhatsApp Image 2025-08-04 at 20 11 45 (3)](https://github.com/user-attachments/assets/b09830bc-d15d-4d2f-a765-1486c24ff880)

---

### **Explanation of Key Elements**

| **Component**                      | **Description**                                              |
| ---------------------------------- | ------------------------------------------------------------ |
| `sky130_fd_sc_hd__mux2_1`          | 2:1 multiplexer standard cell from the Sky130 library        |
| `u1`                               | Instance name (autogenerated or user-defined)                |
| `.A0(n0), .A1(n1), .S(n2), .X(n3)` | Port-to-net connections between cell ports and internal nets |
| `n0‚Äìn3`                            | Internal wires connecting RTL signals to cell ports          |

---

### **Notes**

* This is a **structural netlist**, listing the components and their interconnections.
* It is used in **place and route**, **static timing analysis**, and other backend stages.
* The simplified version generated with `-noattr` is preferred for **manual inspection** or **debugging**.


---

## **Day 2 ‚Äì Timing Libraries, Hierarchical vs Flat Synthesis, and Flop Coding Styles**

### **Lab 4 ‚Äì Introduction to `.lib` Files (Part 1)**

---

### **Introduction to Timing `.lib` Files**

The `.lib` file, also known as a **Liberty file**, contains detailed information about **timing**, **power**, and **functionality** of standard cells used during synthesis.

---

### **Understanding the Contents of a `.lib` File**

A typical `.lib` file includes key data for each standard cell, such as:

* **Timing information** (setup time, hold time, delays)
* **Power consumption** under different conditions
* **Logical functionality** of each cell
* **Pin definitions** and **input/output relationships**

This information is essential for accurate synthesis, timing analysis, and optimization.

Let me know when you're ready to go over the actual structure or syntax of a `.lib` entry.

![WhatsApp Image 2025-08-04 at 22 04 02 (1)](https://github.com/user-attachments/assets/fc6fe209-0a08-45ac-a615-a207019d7b5a)



![WhatsApp Image 2025-08-04 at 22 04 02](https://github.com/user-attachments/assets/0e30de85-317f-4b4e-90ab-80e64db05285)


 **SKY130RTL D2SK1 L2 ‚Äì Lab 4: Introduction to `.lib` Files (Part 1)**:

---

## **Understanding the Contents of a `.lib` File**

---

### **1. Library Declaration**

```text
Library ("sky130_fd_sc_hd__tt_025C_1v80")
```

This line declares the name of the standard cell library being used.

Breakdown:

* **sky130\_fd\_sc\_hd** ‚Äì SkyWater 130nm standard cell library (high-density variant)
* **tt** ‚Äì Typical **PVT** (Process-Voltage-Temperature) corner
* **025C** ‚Äì Temperature: 25¬∞C
* **1v80** ‚Äì Supply voltage: 1.80V

---

### **2. What is a PVT Corner?**

**PVT** stands for **Process**, **Voltage**, and **Temperature**‚Äîthree key factors affecting silicon performance.

| **Parameter** | **Meaning**                                         |
| ------------- | --------------------------------------------------- |
| Process       | Fabrication variation (e.g., fast, slow, typical)   |
| Voltage       | Affects switching speed and power                   |
| Temperature   | Higher temp ‚Üí slower; Lower temp ‚Üí faster switching |

---

### **3. Why Do We Need PVT Corners?**

PVT corners help ensure the design:

* Works under **worst-case**, **best-case**, and **typical** conditions
* Is both **functionally correct** and **timing-safe**

#### **Examples of PVT Corners:**

| **Corner Name** | **Description**                               |
| --------------- | --------------------------------------------- |
| ss\_125C\_1v60  | Slow process, 125¬∞C, 1.60V (worst-case delay) |
| ff\_0C\_1v95    | Fast process, 0¬∞C, 1.95V (best-case delay)    |
| tt\_025C\_1v80  | Typical case for normal operation             |

---

### **Conclusion**

The `.lib` file serves as a **technology reference** for synthesis tools. It enables the tool to:

* Select appropriate **standard cells**
* Estimate **timing and power**
* Perform **PVT-aware technology mapping**

A proper understanding of `.lib` content ensures that the synthesized circuit will operate correctly across all expected real-world conditions.


## **SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2**


Deep Dive into the .lib File
The .lib (Liberty) file contains detailed information about standard cells used during logic synthesis and static timing analysis. Let‚Äôs explore its major contents and structure.


![WhatsApp Image 2025-08-04 at 22 04 02](https://github.com/user-attachments/assets/031bf334-c94c-4bbd-9a65-a8e747c4a3e2)

### 1. Units and Operating Conditions in `.lib` File

---

#### **Defined Units**

The beginning of a `.lib` file sets the standard units for interpretation:

```liberty
time_unit         : "1ns";         // Time in nanoseconds  
voltage_unit      : "1V";          // Voltage in volts  
current_unit      : "1mA";         // Current in milliamperes  
leakage_power_unit: "1nW";         // Leakage power in nanowatts  
pulling_resistance_unit : "1kohm"; // Resistance in kilohms  
capacitance_unit  : "1fF";         // Capacitance in femtofarads  
```

---

#### **Operating Conditions**

```liberty
operating_conditions(tt_025C_1v80) {
  process   : 1;
  voltage   : 1.8;
  temperature : 25;
}
```

These settings define the **PVT corner** under which all timing and power data inside the `.lib` are characterized.

![WhatsApp Image 2025-08-04 at 22 04 02](https://github.com/user-attachments/assets/d41a5318-a61f-40b2-8086-98c73b8f01b2)


### 2. Multiple Cells and Cell Definitions

In a `.lib` file, many standard cells are defined, each beginning with:

```liberty
cell (cell_name) {
    ...
}
```

#### **Example:**

```liberty
cell (sky130_fd_sc_hd__a2111o_1) {
    ...
}
```

Here:

* **sky130\_fd\_sc\_hd\_\_a2111o\_1**: Name of the standard cell.

  * `a2111o`: Indicates the logic function (e.g., AND/OR combination).
  * `_1`: Indicates the drive strength variant.

Each cell block contains information about its:

* Functionality
* Area
* Pin definitions
* Timing characteristics
* Power consumption


![WhatsApp Image 2025-08-04 at 22 07 14 (2)](https://github.com/user-attachments/assets/1d7ee668-dee8-4cd9-bb42-87e85aa19ce2)


This marks the beginning of the definition for the cell sky130_fd_sc_hd__a2111o_1.

---
**Flavours of Cells**

The same logic function may have multiple variants (or flavours), e.g., _0, _1, _2, etc.

These variants differ in driving strength, delay, power consumption, and area.

For example:

*sky130_fd_sc_hd__a2111o_1: Standard drive
*sky130_fd_sc_hd__a2111o_2: Higher drive strength

**Example Cell: sky130_fd_sc_hd__a2111o_1**

*This is a complex gate with 5 inputs: A1, A2, B1, C1, D1.

*The cell performs a specific logic operation defined in both .lib and equivalent Verilog model.

You can view the Verilog model of the library using the following command inside Vim:

```bash
:sp ../my_lib/verilog_model/sky130_fd_sc_hd_a2111oi_0.behavioral.v
```

* `:sp` opens the file in a horizontal split.
* `../my_lib/verilog_model/sky130_fd_sc_hd_a2111oi_0.behavioral.v` is the path to the Verilog model of the Sky130 standard cell library.


![WhatsApp Image 2025-08-04 at 22 07 14 (5)](https://github.com/user-attachments/assets/984c7e3b-7388-4827-a031-9580a230c77a)


**Here's the summarized key information found inside each `cell` block in a `.lib` file:**

| **Parameter**       | **Description**                                                                 |
| ------------------- | ------------------------------------------------------------------------------- |
| `area`              | Physical area of the cell (in square microns)                                   |
| `pin`               | Definition block for each input/output port                                     |
| `input_capacitance` | Intrinsic capacitance of the input pin                                          |
| `power`             | Power consumption info: internal power, leakage, dynamic                        |
| `timing`            | Delay, transition time, and slope-related timing information                    |
| `function`          | Boolean logic function implemented by the cell                                  |
| `related_pin`       | Specifies which other pin affects timing of a given pin (for setup/hold checks) |




![WhatsApp Image 2025-08-04 at 22 07 14 (5)](https://github.com/user-attachments/assets/4f9c354a-af07-47c5-91c6-27c5679478ad)



![WhatsApp Image 2025-08-04 at 22 07 14](https://github.com/user-attachments/assets/c8059516-9daa-49d4-a409-27579ce8e40e)


**Importance in Synthesis and Timing**

The data in the .lib file helps the synthesis tool:

*Estimate propagation delays
*Analyze power and leakage
*Select the most optimal variant of a cell based on constraints
*Ensure that designs meet setup, hold, and clock period requirements

## **SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part3**

Here is a structured explanation for Example 2 on analyzing a smaller gate (AND gate) from the standard cell library. This version is formatted cleanly for use in reports, lab manuals, or documentation:

Example 2: Understanding a Simple Gate ‚Äì AND Gate



![WhatsApp Image 2025-08-04 at 22 04 02 (1)](https://github.com/user-attachments/assets/e34a4df5-094f-4eb7-a649-371691c82007)



Cell Under Study: sky130_fd_sc_hd__and2_0

![WhatsApp Image 2025-08-04 at 22 35 00 (1)](https://github.com/user-attachments/assets/93ce03cd-ded2-4605-9d66-398ed2892b70)

 `sky130_fd_sc_hd__and2_0` cell:

* **Name**: `sky130_fd_sc_hd__and2_0`
* **Type**: 2-input AND gate
* **Function**: Outputs logical AND of two inputs
* **Inputs**: A, B
* **Output**: Y
* **Input Combinations**: 2¬≤ = 4 (00, 01, 10, 11)

**Verilog Model Location**:
You can view its RTL definition in the file:

```
:sp ../my_lib/verilog_model/sky130_fd_sc_hd.v
```

![WhatsApp Image 2025-08-04 at 22 35 00 (2)](https://github.com/user-attachments/assets/17deccde-f28c-44c6-9b0a-987929e7256b)

**Area Analysis Summary**:

* **Goal**: Compare physical area of `and2_0` vs `and2_1` standard cells.

* **Method**:

  1. Open the `.lib` file.
  2. Locate:

     ```liberty
     cell (sky130_fd_sc_hd__and2_0) { ... }
     cell (sky130_fd_sc_hd__and2_1) { ... }
     ```
  3. Find the `area` parameter inside each cell block.

* **Tip**: Use GVim vertical split for side-by-side comparison:

  ```
  :vsp
  ```

This allows a direct visual comparison of area and other attributes.


![WhatsApp Image 2025-08-04 at 22 35 00](https://github.com/user-attachments/assets/72a22388-3989-4577-813f-303dd6b5683a)


![WhatsApp Image 2025-08-04 at 22 35 01 (1)](https://github.com/user-attachments/assets/731b6714-4f67-4ea5-9899-dfb325720a54)


---

**Comparison: and2\_0 vs and2\_1**

| **Cell Name**                 | **Area (Œºm¬≤)** | **Inference**                |
| ----------------------------- | -------------- | ---------------------------- |
| sky130\_fd\_sc\_hd\_\_and2\_0 | Smaller        | Narrower transistors, slower |
| sky130\_fd\_sc\_hd\_\_and2\_1 | Larger         | Wider transistors, faster    |

* and2\_1 has a larger area than and2\_0.
* The larger area implies wider transistors are used in and2\_1.
* Wider transistors can source/sink more current, leading to faster switching, but they occupy more silicon area and consume more power.
* Higher drive strength versions (like \_1, \_2) use wider transistors.
* Wider transistors can charge/discharge load capacitance faster, resulting in lower delay.
* However, they consume more area and often more power.

**Conclusion**
By comparing and2\_0 and and2\_1 in the .lib file:
You observe the trade-off between area and performance.
Larger cells = faster, but costlier in silicon area.
Synthesis tools must choose the right variant based on timing, area, and power constraints.

### **Hierarchical vs Flat Synthesis**

**SKY130RTL D2SK2 L1 ‚Äì Lab 05: Hierarchical and Flat Synthesis (Part 1)**

---

### **What is Hierarchical vs. Flat Synthesis?**

In digital design, a system may be composed of multiple submodules. These can be synthesized using two approaches:

---

### **Hierarchical Synthesis**

* Submodules are preserved as independent blocks.
* Each module is synthesized separately and then connected at the top level.

**Benefits:**

* Faster synthesis for large designs
* Easier modular debugging and reuse

**Drawbacks:**

* Limited global optimization across module boundaries

---

### **Flat Synthesis**

* All submodules are inlined into the top-level module.
* Results in a single flattened netlist.

**Benefits:**

* Better optimization for area, timing, and power

**Drawbacks:**

* Higher memory usage and longer synthesis time
* Harder to trace logic back to original modules

---

### **Example Design: `multiple_modules.v`**

* Located in the `verilog_files` directory
* Defines a hierarchical design using two submodules.

![WhatsApp Image 2025-08-05 at 09 34 36 (1)](https://github.com/user-attachments/assets/f6131963-87c5-45ec-9d1d-59b972e48800)


![WhatsApp Image 2025-08-05 at 09 34 36 (2)](https://github.com/user-attachments/assets/f6dfdfbb-6c01-4fac-b0ec-d65ccbf8cc65)


<img width="829" height="484" alt="Screenshot 2025-08-05 at 9 39 39‚ÄØAM" src="https://github.com/user-attachments/assets/fa5cb7f2-1207-4e16-9343-9f5d04749d4c" />



**Synthesis of multiple_modules.v**

Let‚Äôs now synthesize the multiple_modules.v file.

![WhatsApp Image 2025-08-05 at 09 34 37](https://github.com/user-attachments/assets/88f5c54f-a98c-4d50-a210-ac301db694a7)


![WhatsApp Image 2025-08-05 at 09 34 37 (1)](https://github.com/user-attachments/assets/0580ebc9-b730-4431-950b-25ee14d15e45)

![WhatsApp Image 2025-08-05 at 09 34 37 (2)](https://github.com/user-attachments/assets/f6a3ba26-8647-444d-b2e6-018f15ae4237)

### **Design Structure**

* **Submodules:**

  * `sub_module1`: Implements an AND gate
  * `sub_module2`: Implements an OR gate

* **Top-level module (`multiple_modules`):**

  * Instantiates `sub_module1` as `u1`
  * Instantiates `sub_module2` as `u2`

---

### **Report Summary**

* `sub_module1`: 1 AND gate
* `sub_module2`: 1 OR gate
* `multiple_modules`: 1 instance of each submodule

**Total logic in the design:**

* 1 AND gate
* 1 OR gate

---

### **Linking the Design to the Library in Yosys**

Use the following command:

```bash
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```



![WhatsApp Image 2025-08-05 at 09 34 37 (2)](https://github.com/user-attachments/assets/6c9d73be-0726-46dc-9d50-a38d66455e95)

### **Visualizing the Synthesized Design: Hierarchical View**

After synthesis and linking, use the following Yosys command:

```bash
show multiple_modules
```

This command displays the synthesized gate-level view of the `multiple_modules` design in hierarchical form.


![WhatsApp Image 2025-08-05 at 09 34 37 (4)](https://github.com/user-attachments/assets/99817b59-eeeb-4514-8c99-9e821df1b3b8)

This command opens a graphical representation of the design.

What Do You See?

![WhatsApp Image 2025-08-05 at 09 34 37 (5)](https://github.com/user-attachments/assets/7da138be-97df-4bf4-bc08-83b32e260aba)


### **Hierarchical Synthesis: Visualization and Netlist**

---

### **What We Observe**

* Instead of a gate-level diagram, the view shows:

  * `u1`: Instance of `sub_module1`
  * `u2`: Instance of `sub_module2`

* These are preserved as separate blocks, not expanded into gates.

---

### **Why This Happens**

* The design uses **hierarchical synthesis**.
* Submodules (`sub_module1`, `sub_module2`) are preserved.
* Gates inside submodules are **not flattened**, so they are not visible in the top-level schematic.

---

### **What We Expected vs. What We See**

| **Expectation**               | **Observation**                   |
| ----------------------------- | --------------------------------- |
| AND and OR gates shown        | Only `u1` and `u2` instances seen |
| Flat gate-level logic diagram | Hierarchical module diagram       |

---

### **Writing the Netlist**

To write the netlist in hierarchical form:

```bash
write_verilog -noattr multiple_modules_hier.v
```


![WhatsApp Image 2025-08-05 at 09 34 37 (7)](https://github.com/user-attachments/assets/f290e32b-22be-4afa-ade5-8199ea9c60f7)



![WhatsApp Image 2025-08-05 at 09 34 37 (7)](https://github.com/user-attachments/assets/4fbfab40-7d6c-4ff3-b6c7-ca5cfa96c6c2)

When you open the file, you‚Äôll observe that sub_module1 and sub_module2 are preserved as separate modules in the netlist.

![WhatsApp Image 2025-08-05 at 09 34 37 (8)](https://github.com/user-attachments/assets/e8d564b0-5339-4b40-ba09-c12a4b2f15f2)

![WhatsApp Image 2025-08-05 at 09 34 37 (9)](https://github.com/user-attachments/assets/66eaab34-e4cb-4dc5-85b6-f7d8a125f3a1)


![WhatsApp Image 2025-08-05 at 09 34 36](https://github.com/user-attachments/assets/8be2a93d-7f17-461a-8c6b-75b743bc8862)


**Observation from the Generated Netlist**


When the netlist was generated by the instructor, the structure of sub_module2 appeared different from a straightforward OR gate implementation. It resembled something like the following:

### **Why OR Gate Was Replaced with NAND + Inverters**

---

**Observation:**
The synthesis tool did not use a direct OR gate; instead, it implemented the logic using **inverters and a NAND gate** ‚Äî a **bubbled NAND**, which is logically equivalent to an OR gate.

---

### **Why Did the Synthesis Tool Do This?**

**CMOS Design Principle:**

* **NAND gates** use **stacked NMOS** (fast, area-efficient).
* **NOR gates** use **stacked PMOS** (slow, large area due to low hole mobility).

---

### **Key Reason:**

* **PMOS transistors** have lower mobility than NMOS.
* Stacked PMOS (as in NOR or OR) leads to **larger**, **slower** gates.
* So, the tool **avoids NOR** and **prefers NAND + inverters** (DeMorgan equivalent).

---

### **Conclusion:**

Although RTL says:

```verilog
assign y = a | b;
```

The synthesis tool rewrites it using **CMOS-efficient logic** that:

* Uses fewer/lighter PMOS
* Is **faster** and **area-efficient**
* **Keeps the same logical function**



### **SKY130RTL D2SK2 L2 ‚Äì Lab 05: Hierarchical vs Flat Synthesis (Part 2)**

---

### **Synthesis Behavior**

* **Hierarchical synthesis**:
  `sub_module1` and `sub_module2` appear as **separate blocks** in the netlist.

* **Flat synthesis**:
  All logic is **merged** into `multiple_modules`.
  **Submodule boundaries are removed**.

---

### **Flattening the Design in Yosys**

To flatten the hierarchy:

```bash
flatten
write_verilog -noattr multiple_modules_flat.v
```

![WhatsApp Image 2025-08-06 at 19 16 01 (2)](https://github.com/user-attachments/assets/09c5cbee-632e-4596-b96f-845233719a74)

This generates a flattened netlist named multiple_modules_flat.v.

Comparison with Hierarchical Netlist


![WhatsApp Image 2025-08-06 at 19 16 02](https://github.com/user-attachments/assets/47f3bf24-21e3-48a6-b622-61b1a0941c16)

In the hierarchical netlist, the definitions of sub_module1 and sub_module2 are preserved as separate modules.

In the flattened netlist, the hierarchy is removed.

The logic inside the submodules is inlined into the top-level module.
You directly see the AND and OR gate instantiations within multiple_modules.





![WhatsApp Image 2025-08-06 at 19 16 02 (2)](https://github.com/user-attachments/assets/41bb6e38-3637-4067-a08d-6687dd8905c5)

use command show to see the graphyical representation

show

![WhatsApp Image 2025-08-06 at 19 16 02 (3)](https://github.com/user-attachments/assets/38e3bed4-7e8e-4455-96fa-9aeb2fc3f33a)

### **Conclusion**

* **Flattening** simplifies structure for downstream tools and enables better optimization.
* But it **removes modular boundaries**, making manual interpretation more difficult.

---

### **Submodule-Level Synthesis Example: `sub_module1` (instance `u1`)**

Use the following Yosys commands:

```bash
read_liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog multiple_modules.v
synth -top sub_module1
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```


![WhatsApp Image 2025-08-06 at 19 16 02 (4)](https://github.com/user-attachments/assets/28e151ff-0adf-4f2c-92ab-851ec7f38734)



![WhatsApp Image 2025-08-06 at 19 16 02 (5)](https://github.com/user-attachments/assets/4a68f9da-c8b6-46b5-89ae-924be39be15a)

![WhatsApp Image 2025-08-06 at 19 16 02 (6)](https://github.com/user-attachments/assets/5ea22754-6806-433f-aa5e-9eb52877189a)


![WhatsApp Image 2025-08-06 at 19 16 01](https://github.com/user-attachments/assets/a8ad5983-6a5b-48c6-919e-0a1937cacbf9)

### **What Do We See?**

* `sub_module1` is set as the top module, so **only the AND gate logic** is synthesized.
* The `show` command visualizes **just the AND gate**.
* You **won‚Äôt see** `sub_module2` or `multiple_modules`.

---

### **Why Perform Submodule-Level Synthesis?**

#### 1. **Reuse of Repeated Logic**

* Example: Top-level module contains 6 instances of a multiplier.
* Instead of synthesizing each multiplier:

  * **Synthesize once**
  * **Reuse the synthesized version**
* **Benefits**:

  * Saves time
  * Reduces redundancy
  * Improves efficiency

#### 2. **Divide and Conquer Approach**

* For large/complex designs:

  * **Synthesize submodules independently**
  * **Integrate later into full system**
* **Benefits**:

  * Easier debugging
  * Better timing control
  * Scalable development

---

### **Conclusion**

Submodule-level synthesis allows:

* Efficient handling of repeated modules
* Simplified modular design and optimization
* A scalable approach for large digital systems

---

### **Timing Analysis: Expression `Y = (A & B) | C`**

#### **Gate Delays**

* AND gate = 2 ns
* OR gate = 1 ns

#### **Initial Conditions**

| Signal | Value before 0 ns | Transition at 0 ns |
| ------ | ----------------- | ------------------ |
| A      | 0                 | 0 ‚Üí 1              |
| B      | 0                 | 0 ‚Üí 1              |
| C      | 1                 | 1 ‚Üí 0              |

* Before 0 ns:

  * `(A & B) = 0`
  * `Y = 0 | 1 = 1`

---

### **Step-by-Step Timing**

#### **Time = 0 ns**

* A and B begin rising (0 ‚Üí 1)
* C begins falling (1 ‚Üí 0)

#### **Time = 1 ns**

* OR gate sees:

  * `C = 0`
  * `A & B` output still not ready (AND gate has 2 ns delay ‚Üí output still 0)
* OR computes: `0 | 0 = 0`
* **Y falls to 0 ‚Üí glitch occurs**

#### **Time = 2 ns**

* AND gate output becomes 1 (A = 1, B = 1)
* OR computes: `1 | 0 = 1`
* **Y rises back to 1**

---

###  Final Observation:

* A **glitch** (unintended output pulse) occurs at **1 ns** due to mismatched gate delays.
* **Glitch-free logic** often requires **balancing paths** or adding **buffers/delays**.


<img width="830" height="496" alt="Screenshot 2025-08-06 at 7 29 18‚ÄØPM" src="https://github.com/user-attachments/assets/bfef267e-c66e-4598-9824-09ced21ce7e3" />


### **Conclusion**

* **Y was initially 1**.
* At **1 ns**, both inputs to the OR gate became 0:

  * AND gate output was **not ready yet** (2 ns delay).
  * **C had already dropped** to 0.
* Result: **Y briefly glitched to 0**, then returned to 1 at 2 ns.
* This is a **Static-1 hazard**, caused by **unbalanced path delays**.

---

### **Why We Need a Flip-Flop in Digital Circuits**

#### **Combinational Circuit Limitation**

* Outputs **directly follow inputs**, including glitches from delay mismatches.
* Without control, **glitches can propagate** endlessly.
* This is **unreliable**, especially in sequential systems.

---

### **Role of Flip-Flops**

* Flip-flops (like **D flip-flop**) act as **storage elements**.
* Functions:

  * **Capture and hold** stable output from a combinational block.
  * **Block glitches** from affecting downstream logic.
  * **Synchronize updates** using a **clock edge**.

#### **Behavior**

* Flip-flop updates output only on a **clock edge**.
* **Glitchy changes between edges are ignored**.
* Only the **final, stable value** is passed forward.

---

### **Why Initialization Is Important**

* Without initialization, **flip-flop output is undefined**.
* This may cause **incorrect logic evaluations**.
* Solution:

  * Use **reset** or **set** signal during startup.
  * Ensures system begins in a **known, valid state**.

## **SKY130RTL D2SK3 L2 Why Flops and Flop coding styles part2**



<img width="821" height="562" alt="Screenshot 2025-08-06 at 7 31 44‚ÄØPM" src="https://github.com/user-attachments/assets/517d2cea-4c69-4c96-aca5-269acda0c9c1" />


## **SKY130RTL D2SK3 L3 Lab flop synthesis simulations part1**

### **1) D Flip-Flop with Asynchronous Reset**

#### **Verilog Code: `dff_async_reset.v`**

```verilog
module dff_async_reset (
    input clk,
    input rst,
    input d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 0;
    else
        q <= d;
end

endmodule
```

---

#### **Testbench: `tb_dff_async_reset.v`**

```verilog
`timescale 1ns/1ps

module tb_dff_async_reset;

reg clk, rst, d;
wire q;

dff_async_reset uut (
    .clk(clk),
    .rst(rst),
    .d(d),
    .q(q)
);

always #5 clk = ~clk;

initial begin
    $dumpfile("tb_dff_async_reset.vcd");
    $dumpvars(0, tb_dff_async_reset);

    clk = 0; rst = 0; d = 0;

    #3  rst = 1;
    #7  rst = 0;
    #5  d = 1;
    #10 d = 0;
    #10 $finish;
end

endmodule
```


![WhatsApp Image 2025-08-06 at 19 36 02](https://github.com/user-attachments/assets/a32f10f4-2b3b-4f9f-8cbc-59fe4e712c91)



![WhatsApp Image 2025-08-06 at 19 36 02 (1)](https://github.com/user-attachments/assets/78dcdc4e-5d5d-4b36-b1d7-3de80af8792b)

2) D FlipFlop with Synchronous reset


<img width="814" height="151" alt="Screenshot 2025-08-06 at 7 41 17‚ÄØPM" src="https://github.com/user-attachments/assets/46195d07-1865-437e-812d-fd69c15ba112" />

<img width="831" height="827" alt="Screenshot 2025-08-06 at 7 41 30‚ÄØPM" src="https://github.com/user-attachments/assets/54b587d5-5917-4570-bb68-1e10d7d83533" />



![WhatsApp Image 2025-08-06 at 19 36 03](https://github.com/user-attachments/assets/c4634ba4-e146-4709-bbf4-1769623d6876)


![WhatsApp Image 2025-08-06 at 19 36 01](https://github.com/user-attachments/assets/85d3cf0e-ae5f-41fd-b550-5e288d69181b)


3)  D FlipFlop with Asynchronous set



<img width="822" height="167" alt="Screenshot 2025-08-06 at 7 44 07‚ÄØPM" src="https://github.com/user-attachments/assets/4156bcaf-b9d2-4a37-90ca-dded23c84218" />

<img width="833" height="776" alt="Screenshot 2025-08-06 at 7 44 24‚ÄØPM" src="https://github.com/user-attachments/assets/9348265a-cf89-47ce-88c3-04ac32bfe079" />


![WhatsApp Image 2025-08-06 at 19 36 02 (3)](https://github.com/user-attachments/assets/33a0de70-9c3b-461f-ad04-69b1f413cd5a)

![WhatsApp Image 2025-08-06 at 19 36 02 (4)](https://github.com/user-attachments/assets/ce326842-c19d-46a7-acd0-f706b409de7b)

### **SKY130RTL D2SK3 L4 ‚Äì Lab: Flip-Flop Synthesis Simulations (Part 2)**

---

### **1) D Flip-Flop with Asynchronous set**

---

### **Why We Use `dfflibmap` in Synthesis Flow**

* In many flows, **flip-flops are stored separately** from logic gates in the library.
* `dfflibmap` is used to **map generic flip-flops** in RTL to **specific flip-flop cells** in the standard cell library.

---

### **Yosys Synthesis Flow**

```bash
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_async_reset.v
synth -top dff_async_reset
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
write_verilog -noattr dff_async_reset_netlist.v
```

![WhatsApp Image 2025-08-06 at 19 57 19 (3)](https://github.com/user-attachments/assets/6c00350d-19e3-48b0-9ff5-af2d41e2f815)


![WhatsApp Image 2025-08-06 at 19 57 19 (4)](https://github.com/user-attachments/assets/4525b727-45ac-4364-9ebe-ac78a85db065)

![WhatsApp Image 2025-08-06 at 19 57 19 (5)](https://github.com/user-attachments/assets/2b6dac58-19c9-4175-8bbd-f46e0f57a3f2)

![WhatsApp Image 2025-08-06 at 19 57 19 (6)](https://github.com/user-attachments/assets/1dc5fd81-dbca-4982-89a3-e12c633b1092)



![WhatsApp Image 2025-08-06 at 19 57 19 (7)](https://github.com/user-attachments/assets/8f4ad8b6-103f-44f2-9177-e6d2e34fd86c)

**Why the Tool Inserted an Inverter**

In the Verilog code, the D flip-flop is written with an active-high reset condition:

```verilog
if (reset)
    q <= 0;
```

However, the standard cell library may only contain flip-flops with active-low reset functionality.

To resolve this mismatch, the synthesis tool automatically inserts an inverter in front of the reset signal. This converts the active-high reset logic used in the RTL to match the active-low reset behavior expected by the physical flip-flop cell in the library.

---

**Why `dfflibmap` is Important**

Without `dfflibmap`, the flip-flop may not be mapped correctly to a physical cell.

This can result in either:

* Synthesis failure
* An incomplete netlist (no physical representation for your DFF)


**2) D FlipFlop with Synchronous reset**

![WhatsApp Image 2025-08-06 at 19 57 19 (8)](https://github.com/user-attachments/assets/f8370f0d-0a05-49f9-87b6-aaedbe152c73)


![WhatsApp Image 2025-08-06 at 19 57 19 (9)](https://github.com/user-attachments/assets/ef7e6715-d862-4e96-92c0-98617f49170d)


![WhatsApp Image 2025-08-06 at 19 57 19 (10)](https://github.com/user-attachments/assets/f4bba112-0ebc-4a30-90e5-74f55bf87598)



![WhatsApp Image 2025-08-06 at 19 57 19](https://github.com/user-attachments/assets/98b959ac-10d5-4fa9-9bef-d5329d260b83)


### **SKY130RTL D2SK3 L5 ‚Äì Interesting Optimizations Part 1**

---

### **File: `mul2.v`**

```verilog
module mul2 (input [2:0] a, output [3:0] y);
    assign y = a * 2;
endmodule
```

### **Optimization Insight: Multiplication by Constant Power of 2**

---

At first glance, the `*` operator implies a hardware multiplier.
But multiplication by a power of 2 is just a bitwise left shift.

---

#### **Example**

```
5 √ó 4 = 20  
0101 √ó 4 = 10100  ‚Üí left shift by 2
```

---

#### **Equivalents**

* `a * 2` ‚Üí `a << 1`
* `a * 4` ‚Üí `a << 2`
* `a * 2‚Åø` ‚Üí `a << n`

---

### **Effect of Synthesis on `mul2`**

Synthesis tool transforms:

```verilog
y = a * 2;
```

into:

```verilog
y = a << 1;
```

Hence, **no hardware multiplier cells** are inferred.

![WhatsApp Image 2025-08-06 at 20 18 47 (1)](https://github.com/user-attachments/assets/7b74255e-6444-4727-a5be-a8777809b5e1)


![WhatsApp Image 2025-08-06 at 20 18 47 (3)](https://github.com/user-attachments/assets/c19c1e1b-0ce3-47aa-bf94-a781847c7c20)


![WhatsApp Image 2025-08-06 at 20 18 47 (4)](https://github.com/user-attachments/assets/94494264-2f09-4106-87a9-083594053d99)


![WhatsApp Image 2025-08-06 at 20 18 48](https://github.com/user-attachments/assets/1d563e5f-f89e-4b20-92a2-621049dc42d6)



![WhatsApp Image 2025-08-06 at 20 18 47](https://github.com/user-attachments/assets/b4597cc0-2262-48f6-8157-916637bed432)



<img width="831" height="375" alt="Screenshot 2025-08-06 at 8 30 15‚ÄØPM" src="https://github.com/user-attachments/assets/2e035142-416e-41a7-8eac-97712796ac36" />




<img width="832" height="201" alt="Screenshot 2025-08-06 at 8 30 37‚ÄØPM" src="https://github.com/user-attachments/assets/08fdc0f9-a7e9-42a2-b928-9efcb85d3c58" />




So instead of generating a multiplier, the tool simply wires the bits accordingly ‚Äî no actual multiplier hardware is required.

This is a classic strength reduction optimization applied during synthesis


### **SKY130RTL D2SK3 L6 ‚Äì Interesting Optimizations Part 2**

---

### **Verilog Case: Multiply by 9**

```verilog
input  [2:0] a;
output [5:0] y;

assign y = a * 9;
```

---

### **Optimization Insight**

* $9 = 8 + 1 = (1 << 3) + 1$
* So:
  $a * 9 = (a << 3) + a$

---

### **Binary View**

* Let `a = 3'babc`
* `a << 3 = {a, 000}`
* Adding `a` back:
  $(a << 3) + a = {a, a}$

---

### **Conclusion**

```verilog
y = {a, a};
```

* No multiplier is used
* Just concatenation and wiring
* File name: `mul8.v` (but functionally multiplies by 9)


![WhatsApp Image 2025-08-06 at 20 18 47](https://github.com/user-attachments/assets/96821fda-ba65-4070-a7a4-3dd2a04d059e)


<img width="832" height="409" alt="Screenshot 2025-08-06 at 8 34 17‚ÄØPM" src="https://github.com/user-attachments/assets/01b04d99-122b-4e5e-b9a2-dc474f984c67" />




<img width="833" height="396" alt="Screenshot 2025-08-06 at 8 34 28‚ÄØPM" src="https://github.com/user-attachments/assets/014a08ae-9ec9-431e-9557-3019de0c0c4e" />



<img width="833" height="396" alt="Screenshot 2025-08-06 at 8 34 28‚ÄØPM" src="https://github.com/user-attachments/assets/22593f33-765d-4236-bcdb-79d3a8f936d4" />




### **SKY130RTL D3SK1 L1 ‚Äì Introduction to Optimizations Part 1**

---

### **Combinational Logic Optimization**

**Objective:**
Simplify logic circuits to reduce **area**, **power**, and sometimes **delay**, without changing functionality.

---

### **Key Techniques for Optimization**

#### **1. Constant Propagation (Direct Optimization)**

* If a signal is driven by a constant (`0` or `1`), logic can be simplified at compile time.

Examples:

```verilog
assign y = a & 1'b0;  // optimized to y = 0
assign z = b | 1'b1;  // optimized to z = 1
```

### **2. Boolean Logic Optimization**

Involves algebraic simplification of logic expressions using Boolean identities.

---

#### **a) Karnaugh Map (K-Map)**

* Visual simplification method (best for ‚â§ 4‚Äì5 variables)
* Groups adjacent 1s in the truth table
* Reduces logic expressions by identifying common terms

---

#### **b) Quine‚ÄìMcCluskey Method**

* Tabular, algorithmic technique for Boolean minimization
* Suitable for automation
* Can handle more variables than K-map
* Produces a deterministic minimal form


Conclusion

Optimizing combinational logic reduces hardware cost and improves power efficiency. Techniques like constant propagation, K-map, and Quine‚ÄìMcCluskey are fundamental to achieving these improvements during synthesis.



### **SKY130RTL D3SK1 L2 & L3 ‚Äì Introduction to Optimizations Part 2 & 3**

---

### **Sequential Logic Optimization**

**Goal:**
Optimize designs with **flip-flops**, **latches**, and **state machines** to reduce **area**, **power**, or improve **timing**, while preserving behavior.

---

### **Types of Sequential Logic Optimization**

#### **1. Basic Optimization**

**Sequential Constant Propagation**

* Similar to constant propagation in combinational logic
* Applied across clocked elements
* If a flip-flop is driven by a constant (or becomes constant),
  ‚Üí the flip-flop and dependent logic can be eliminated

**Example:**

```verilog
always @(posedge clk)
  q <= 1'b1;  // Can be optimized to a constant wire
```

### **2. Advanced Optimizations** *(Not covered in lab)*

---

#### **State Optimization**

* Minimizes the number of states or improves encoding in FSMs
* Techniques: **Gray code**, **one-hot encoding**
* Benefits: Reduces **switching activity** or **logic size**

---

#### **Retiming**

* Moves flip-flops across combinational logic
* Maintains functional behavior
* Balances **path delays** to meet **timing constraints**

---

#### **Sequential Logic Cloning** *(Floorplan-Aware Synthesis)*

* Duplicates flip-flops to reduce **routing congestion**
* Balances **timing** across chip regions
* Used in **physical-aware synthesis** (layout-aware)

---

### **Conclusion**

Sequential logic optimization:

* **Improves timing**
* **Reduces area**
* **Minimizes power**

Basic methods (e.g., constant propagation) are early-stage
Advanced methods (e.g., retiming, FSM optimization) are used in **performance-critical** and **layout-aware** design flows.



### **SKY130RTL D3SK2 L1 & L2: Lab06 ‚Äì Combinational Logic Optimizations**

---

#### **Lab Overview**

We will be using the following Verilog files for combinational logic optimization:

* `opt_bool1.v`
* `opt_bool2.v`
* `opt_bool3.v`

Each file demonstrates different cases of Boolean expression optimization and synthesis behavior.
The goal is to understand how the synthesis tool simplifies logic to reduce area and power while preserving the intended functionality.

---














