# RTL_Design_and_Synthesis
---

## Day 1 ‚Äì Introduction to Verilog RTL Design and Synthesis

## Getting Started with the Open-Source Simulator: Icarus Verilog (iverilog)

A **simulator** is a tool used to verify whether a digital design behaves according to its specifications. In RTL (Register Transfer Level) design, simulation helps confirm that the logic works correctly by applying various input conditions and observing the outputs.

For this course, we will use **Icarus Verilog (iverilog)**‚Äîan open-source Verilog simulation tool.

### What is a Design?

A *design* refers to the Verilog code or a set of modules written in Verilog that describe the desired hardware functionality according to the given specifications.

### What is a Test Bench?

A *test bench* is a setup used to verify the design. It provides the necessary input signals (also known as test vectors) and checks the resulting outputs. The test bench mimics a real-world environment to ensure the design functions as expected.

** How Does a Simulator Work?

The simulator operates by monitoring changes in input signals.

* When an input changes, it triggers the simulator to evaluate and update the corresponding outputs.
* If there is no input change, the outputs remain the same.

This *event-driven* approach ensures efficient simulation by responding only to signal transitions.

### Design and Test Bench Structure

* The **design** includes one or more *primary inputs* and *primary outputs*.
* The **test bench** includes:

  * A **stimulus generator** to apply inputs to the design.
  * A **stimulus observer** to monitor and verify the outputs.

Together, these components create a simulation environment where the test bench interacts with the design.

> **Note:** The test bench itself does not have any primary inputs or outputs. It functions entirely within the simulation environment and is not part of the synthesized hardware.


<img width="831" height="394" alt="Screenshot 2025-08-04 at 7 19 57‚ÄØPM" src="https://github.com/user-attachments/assets/4489e1dc-ca90-4ce6-9793-c76921c81c88" />



Iverilog-based simulation flow:

The design and test bench are provided as inputs to iverilog. As mentioned earlier, the simulator monitors changes in input signals and updates the output accordingly. The output generated by the simulator is a .vcd file, which stands for Value Change Dump format.

To view this output waveform, we use GTKWave.


<img width="832" height="375" alt="Screenshot 2025-08-04 at 7 20 17‚ÄØPM" src="https://github.com/user-attachments/assets/784b4edf-70eb-4033-aba6-116ade6a6e68" />



### **Labs Using Icarus Verilog and GTKWave**

**SKY130RTL D1SK2 L1 ‚Äì Lab 1: Introduction to the Lab**

---

### **Toolflow and File Setup for Lab Exercises**

To begin working on the labs, you'll need to set up the appropriate toolchain and directory structure.

---

#### **Step 1: Create a Project Directory**

Start by creating a directory to hold all lab-related files, and navigate into it:

```bash
mkdir VLSI
cd VLSI
```

---

#### **Step 2: Clone Required GitHub Repositories**

Next, clone the necessary repositories that contain lab content and support files:

1. **sky130RTLDesignAndSynthesisWorkshop** ‚Äì Contains the RTL design and synthesis labs

```bash
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
```

2. **vsdflow** ‚Äì Contains the helper scripts and flow setup for simulations

```bash
git clone https://github.com/kunalg123/vsdflow.git
```

---

#### **Directory Structure After Setup**

Once the cloning is complete, your folder structure will be:

```
VLSI/
‚îú‚îÄ‚îÄ sky130RTLDesignAndSynthesisWorkshop/
‚îî‚îÄ‚îÄ vsdflow/
```

You are now ready to start with the lab exercises using **Icarus Verilog (iverilog)** for simulation and **GTKWave** for waveform visualization.


<img width="826" height="407" alt="Screenshot 2025-08-04 at 7 25 09‚ÄØPM" src="https://github.com/user-attachments/assets/1fa040e9-5106-4b63-91e4-57a8923fb52e" />


<img width="829" height="390" alt="Screenshot 2025-08-04 at 7 25 17‚ÄØPM" src="https://github.com/user-attachments/assets/fae477c7-3dbe-4f78-9dd6-aee1e77ab2e8" />



---

### **Lab 2 ‚Äì Introduction to Icarus Verilog and GTKWave (Part 1)**

**Tool Installation Guide**

To run the simulation labs successfully, you need to install the following tools:

---

#### **1. Install Icarus Verilog (iverilog)**

Icarus Verilog is a compiler and simulator for Verilog HDL.

Use the following command in the terminal to install:

```bash
sudo apt-get install iverilog
```

---

#### **2. Install GTKWave**

GTKWave is a waveform viewer used to visualize simulation outputs.

Install it with:

```bash
sudo apt-get install gtkwave
```

---

Once installed, these tools will enable you to:

* **Compile and simulate** your Verilog designs using `iverilog`
* **View and analyze** signal waveforms using `gtkwave`



![WhatsApp Image 2025-08-04 at 19 31 31 (1)](https://github.com/user-attachments/assets/3605abcf-d004-4485-9c1a-f5910d36be78)


![WhatsApp Image 2025-08-04 at 19 31 32 (1)](https://github.com/user-attachments/assets/51b75556-ebeb-4df2-a634-5f75b512b8ae)


![WhatsApp Image 2025-08-04 at 19 31 31](https://github.com/user-attachments/assets/238e0dbe-b689-432c-b2b2-2f23c6390355)


![WhatsApp Image 2025-08-04 at 19 31 32 (2)](https://github.com/user-attachments/assets/6083af95-f11d-405e-a2cf-9fbf9082c780)



---

## **Lab 2 ‚Äì Part 2: Simulating and Visualizing `good_mux` Design**

### **1. Verilog Design File: `good_mux.v`**

```verilog
module good_mux (input i0, input i1, input sel, output reg y);

  always @(*) begin
    if (sel)
      y = i1;
    else
      y = i0;
  end

endmodule
```

#### üîç **Explanation:**

* **Inputs:** `i0`, `i1`, `sel` ‚Äì all are 1-bit signals.
* **Output:** `y` ‚Äì 1-bit output declared as `reg` because it is assigned inside an `always` block.
* **Functionality:** Implements a **2:1 multiplexer**.

  * If `sel = 1`, then `y = i1`.
  * If `sel = 0`, then `y = i0`.
* The `always @(*)` block ensures the logic is sensitive to all input changes.

---

### **2. Testbench File: `tb_good_mux.v`**

```verilog
`timescale 1ns / 1ps

module tb_good_mux;

  // Inputs
  reg i0, i1, sel;

  // Output
  wire y;

  // Instantiate the Unit Under Test (UUT)
  good_mux uut (
    .i0(i0),
    .i1(i1),
    .sel(sel),
    .y(y)
  );

  initial begin
    $dumpfile("tb_good_mux.vcd");      // Dump file for GTKWave
    $dumpvars(0, tb_good_mux);         // Record all variables under tb_good_mux

    // Initialize Inputs
    sel = 0;
    i0 = 0;
    i1 = 0;

    // Run simulation for 300 ns
    #300 $finish;
  end

  // Toggle sel every 75 ns
  always #75 sel = ~sel;

  // Toggle i0 every 10 ns
  always #10 i0 = ~i0;

  // Toggle i1 every 55 ns
  always #55 i1 = ~i1;

endmodule
```

---

### **üî¨ Testbench Behavior Summary:**

* **Simulation Time:** 300 ns total
* **Signal Toggles:**

  * `sel` toggles every 75 ns ‚Üí switches MUX input selection.
  * `i0` toggles every 10 ns.
  * `i1` toggles every 55 ns.
* **Expected Behavior:**

  * Output `y` follows either `i0` or `i1` depending on the value of `sel`.
* **Waveform Output:**

  * Stored in `tb_good_mux.vcd`
  * Can be viewed using GTKWave:

    ```bash
    gtkwave tb_good_mux.vcd
    ```

---
## Introduction to Yosys and Logic synthesis

## SKY130RTL D1SK3 L1 Introduction to yosys

Introduction to Yosys
Yosys is the synthesizer tool used in this course. It is responsible for converting RTL (Register Transfer Level) code into a gate-level netlist using standard cells.

Role of Synthesizer:
A synthesizer takes a digital RTL design and a standard cell library (.lib file) and generates a netlist that represents the circuit using gates and cells from the library.

Yosys Synthesis Flow:
Inputs to Yosys:

The RTL design (.v file)
The standard cell library (.lib file)

<img width="834" height="239" alt="Screenshot 2025-08-04 at 7 37 37‚ÄØPM" src="https://github.com/user-attachments/assets/f992e81f-9edf-4d6f-a391-4053d8548694" />

Yosys Commands:

read_verilog ‚Äì Reads the Verilog design file.
read_liberty ‚Äì Reads the .lib file containing timing and cell information.
write_verilog ‚Äì Writes out the synthesized netlist.


<img width="827" height="435" alt="Screenshot 2025-08-04 at 7 37 48‚ÄØPM" src="https://github.com/user-attachments/assets/dd43062d-c272-4f8f-b6b5-b09f8727e5c0" />

Output:

A netlist file representing the design using standard cells from the .lib library.
Netlist Verification:
To verify if the synthesis process was successful and functionally correct:

Use the same testbench that was used for the original RTL simulation.
Apply the synthesized netlist and the testbench to the simulator (Icarus Verilog).
Generate the VCD (.vcd) file.
Load the VCD file in GTKWave and compare the waveform output.


<img width="834" height="393" alt="Screenshot 2025-08-04 at 7 41 19‚ÄØPM" src="https://github.com/user-attachments/assets/5e2cbc77-e89c-43d1-b89c-c10b6c91cbeb" />


Important Notes:

The stimulus in the testbench must match the one used during RTL simulation.
The primary inputs and outputs of the netlist remain the same as the RTL design.
Therefore, the same testbench can be reused for post-synthesis simulation.


<img width="830" height="450" alt="Screenshot 2025-08-04 at 7 41 50‚ÄØPM" src="https://github.com/user-attachments/assets/259affc8-2643-4feb-9c52-5462de15f019" />



---

## **SKY130RTL D1SK3 L2 ‚Äì Introduction to Logic Synthesis (Part 1)**

### **Logic Synthesis Overview**

---

### **1. RTL Design**

RTL (Register Transfer Level) design is the behavioral representation of a digital system based on its required specification.
It defines how data moves between registers and how operations are performed on that data.


<img width="829" height="765" alt="Screenshot 2025-08-04 at 7 43 08‚ÄØPM" src="https://github.com/user-attachments/assets/45e371c8-4ce7-41fd-a651-598d2808dab8" />


<img width="828" height="582" alt="Screenshot 2025-08-04 at 7 43 16‚ÄØPM" src="https://github.com/user-attachments/assets/b7047c1c-9f9f-47a3-8fd1-24d8d654c293" />


---

### **2. What is Logic Synthesis?**

Logic synthesis is the process of converting RTL code into a digital logic circuit.
This involves translating behavioral descriptions into a network of logic gates.
The transition from RTL to gate-level design is called synthesis.
The final output of this process is a netlist, which describes the gates and their interconnections.

---

### **3. Inputs and Outputs of Synthesis**

**Inputs:**

* RTL Design (written in Verilog or VHDL)
* Technology Library (.lib file)

**Output:**

* Gate-level netlist (.v file)

### **4. What is a .lib File?**

A `.lib` file is a collection of logic cells provided by a standard cell library.

It includes basic gates like AND, OR, NOT, and their variants:

* Different input configurations (e.g., 2-input OR, 3-input OR)
* Different speed-power tradeoffs (e.g., slow, medium, fast cells)

### ***5. Why Different Flavours of Gates?***
The combinational delay in a logic path directly affects the maximum speed of a digital circuit.

<img width="825" height="366" alt="Screenshot 2025-08-04 at 7 50 04‚ÄØPM" src="https://github.com/user-attachments/assets/6fbaebb5-27e3-4638-889e-329ff7750f83" />


### **Clock Cycle Constraint**

The clock cycle must satisfy the following condition:

```
Tclk > Tcq_A + Tcomb + Tsetup_B
```

Where:

* **Tcq\_A** = Clock-to-Q delay of DFF A
* **Tcomb** = Delay of the combinational logic
* **Tsetup\_B** = Setup time of DFF B

To minimize **Tcomb**, faster cells from the `.lib` file are used.
This reduces the required clock period (**Tclk**) and increases the operating frequency.

---

### **6. Maximum Clock Frequency**

The minimum clock period defines the maximum frequency:

```
fclk(max) = 1 / Tclk(min)
```

<img width="832" height="273" alt="Screenshot 2025-08-04 at 7 50 22‚ÄØPM" src="https://github.com/user-attachments/assets/dbd1e0ce-aff0-4e06-9dc4-8a0614d30883" />

### **SKY130RTL D1SK3 L3 ‚Äì Introduction to Logic Synthesis (Part 2)**

---

### **Are Faster Cells Sufficient?**

At first glance, it might seem that using only faster cells is the key to achieving maximum performance.
After all, higher clock speeds typically mean better performance.
But this leads to an important question:

**If faster cells minimize delay, why are slower cells needed at all?**

---

### **Why Do We Need Slow Cells?**

To meet timing constraints, both **setup** and **hold** times must be satisfied:

* For **setup time** (performance constraint), data must arrive **before** the clock edge.
* For **hold time** (reliability constraint), data must remain **stable briefly after** the clock edge.



<img width="831" height="261" alt="Screenshot 2025-08-04 at 7 51 54‚ÄØPM" src="https://github.com/user-attachments/assets/2ef45725-7cf3-4f8d-9df7-3474e9408dc2" />

---

### **If the Combinational Delay is Too Short**

Hold time may be violated if:

```
Thold_B < Tcq_A + Tcomb
```

Therefore:

* **Faster cells** help reduce `Tcomb` to meet **setup timing**.
* **Slower cells** help increase `Tcomb` to prevent **hold time violations**.

The `.lib` file provides both types of cells to offer flexibility in timing closure.

---

### **Understanding Hold Time**

Hold time is the **minimum time** after a clock edge during which the input must remain **stable**.

* If data at flip-flop B changes too quickly, it may capture **incorrect data**.
* **Slower cells** introduce delay to help satisfy hold time constraints.

---

### **Faster vs. Slower Cells**

| **Parameter**    | **Faster Cells**      | **Slower Cells**          |
| ---------------- | --------------------- | ------------------------- |
| Transistor Width | Wider (more current)  | Narrower (less current)   |
| Delay            | Lower                 | Higher                    |
| Area             | Larger                | Smaller                   |
| Power            | Higher                | Lower                     |
| Use Case         | Improves setup timing | Helps fix hold violations |

---

### **Trade-Offs: Speed vs. Area/Power**

* **Faster cells**: Improve performance, but increase **area**, **power**, and **risk of hold violations**.
* **Slower cells**: Save power and area, and help with **hold timing**, but may **fail setup timing**.

---

### **Cell Selection: Guided by Constraints**

The synthesis tool selects cells, but we guide it using constraints:

* **Too many fast cells** ‚Üí High power, large area, hold issues
* **Too many slow cells** ‚Üí Fails setup timing

**Constraints include:**

* Timing (clock period, setup/hold margins)
* Area and power limits
* Design goals and trade-offs

---

### **Conclusion**

Synthesis is not just about functionality‚Äîit‚Äôs about **efficiency**.
Choosing between faster and slower cells is a critical trade-off, handled by synthesis tools using design constraints.


<img width="831" height="601" alt="Screenshot 2025-08-04 at 7 53 11‚ÄØPM" src="https://github.com/user-attachments/assets/7f334287-feb1-4431-b713-7bd257a1f3ea" />

---

## **Labs Using Yosys and SKY130 PDKs**

### **Lab 3: Yosys ‚Äì Part 1 (good\_mux)**

### **Introduction to Synthesizer: Yosys**

**Yosys** is an open-source synthesis tool used to convert RTL code into a gate-level netlist using a specified standard cell library.

---

### **Steps to Invoke and Use Yosys**

#### **Step 1: Start Yosys**

Open a terminal and navigate to your working directory:

```bash
cd verilog_files
```

Start Yosys by typing:

```bash
yosys
```

---

#### **Step 2: Read the Standard Cell Library**

Yosys must load the standard cells before synthesis. Use the following command:

```tcl
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```

---

#### **Step 3: Read the Verilog Design**

Load your RTL design file (e.g., `good_mux.v`) with:

```tcl
read_verilog good_mux.v
```

![WhatsApp Image 2025-08-04 at 19 58 30 (1)](https://github.com/user-attachments/assets/eecddd99-57ca-45d2-9c57-9ef1c17831a0)


![WhatsApp Image 2025-08-04 at 19 58 31](https://github.com/user-attachments/assets/65d8a5e1-a9b5-422c-b48b-fffea0433f22)



![WhatsApp Image 2025-08-04 at 19 58 31 (1)](https://github.com/user-attachments/assets/4cdbf5c2-cb1b-4fd1-a79d-9a321c0d31de)


3. Perform Synthesis
Specify the top module of the design:

synth -top good_mux


![WhatsApp Image 2025-08-04 at 19 58 31 (2)](https://github.com/user-attachments/assets/3b357c7c-859a-46af-b4bf-e7f25b578511)

![WhatsApp Image 2025-08-04 at 19 58 31 (3)](https://github.com/user-attachments/assets/14f8f6e3-b404-479a-bc9a-be22e1854d83)


4. Technology Mapping
Map the synthesized design to standard cells defined in the .lib file:

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

![WhatsApp Image 2025-08-04 at 19 58 31 (6)](https://github.com/user-attachments/assets/5edd8efa-bb9d-4a3b-bec4-68fe68cc5fb1)


At this stage, the synthesis is complete and the result is a netlist using specific standard cells.

5. Analyze the Output

![WhatsApp Image 2025-08-04 at 19 58 31 (7)](https://github.com/user-attachments/assets/7e6893fe-145b-4984-81db-05bec8ee0d0c)


---

### **Compare the Netlist with the Original `good_mux.v`**

**Note:**

* The synthesized netlist will not show internal signals.
* Only the 3 inputs and 1 output are retained, matching the original RTL design.
* The standard cell used is: `mux2_1`.

---

### **Visualize the Logic**

To view a graphical representation of the synthesized circuit, use the following command in Yosys:

```tcl
show
```


![WhatsApp Image 2025-08-04 at 19 58 30](https://github.com/user-attachments/assets/2b4940fb-c729-4e0a-a560-f63662bb28c1)

## **SKY130RTL D1SK4 L2 Lab3 Yosys 1 good mux Part2**

Corresponding Verilog Code

![WhatsApp Image 2025-08-04 at 19 58 31 (5)](https://github.com/user-attachments/assets/bf1c3690-e5e6-4767-96d7-52ca2c1a27dd)

---

### **Explanation of the Yosys Output Image**

The image generated using the `show` command in Yosys represents the **gate-level implementation** of the `good_mux` module, synthesized using the **Sky130** standard cell library.

---

### **Block-by-Block Explanation**

| **Element**               | **Description**                                             |
| ------------------------- | ----------------------------------------------------------- |
| `i0`, `i1`, `sel`         | Input signals entering from the left.                       |
| `$86`                     | Internal instance name automatically generated by Yosys.    |
| `sky130_fd_sc_hd__mux2_1` | 2:1 multiplexer standard cell from the Sky130 library.      |
| `A0`, `A1`, `S`           | Inputs to the multiplexer: `A0 = i0`, `A1 = i1`, `S = sel`. |
| `X`                       | Output of the multiplexer.                                  |
| `y`                       | Final output of the module, connected to the mux output.    |
| `good_mux`                | Name of the top-level RTL module.                           |

---

### **Mapping Between RTL and Synthesized Logic**

* The RTL `always` block uses an `if-else` condition to assign `y` based on `sel`.
* Yosys recognizes this as a **2:1 multiplexer** during synthesis.
* It replaces the behavioral logic with a `sky130_fd_sc_hd__mux2_1` cell.
* This cell has inputs `A0`, `A1`, and `S`, and one output `X` which drives `y`.

---

### **Conclusion**

Yosys has successfully:

* Synthesized the RTL to a **gate-level netlist**.
* Mapped the logic to a **Sky130 multiplexer cell**.
* Optimized internal signals into direct standard cell connections.

---

### **Writing the Netlist in Yosys**

After synthesis and technology mapping, export the netlist using:

```tcl
write_verilog good_mux_netlist.v
```

This saves the synthesized gate-level design to `good_mux_netlist.v`.

Let me know if you‚Äôd like to continue with simulation of the netlist or preparing it for physical design.

![WhatsApp Image 2025-08-04 at 20 11 45 (1)](https://github.com/user-attachments/assets/9cda7b3b-eb3c-4d63-a713-bba457ad7d6e)

---

### **Generating the Netlist**

By default, Yosys generates a netlist file named:

```
good_mux_netlist.v
```

---

### **Creating a Simplified Netlist**

To generate a cleaner version of the netlist‚Äîexcluding attributes like timing, area, etc.‚Äîuse:

```tcl
write_verilog -noattr good_mux_netlist.v
```

This version is easier to read and focuses only on the **structural connections** in the design.


![WhatsApp Image 2025-08-04 at 20 11 45](https://github.com/user-attachments/assets/187fe4e6-5f33-4a0b-bc89-930c62ac408f)


![WhatsApp Image 2025-08-04 at 20 11 45 (2)](https://github.com/user-attachments/assets/61601c9e-a4fa-4394-8f86-c4bb5fe1f2f4)

![WhatsApp Image 2025-08-04 at 20 11 45 (3)](https://github.com/user-attachments/assets/b09830bc-d15d-4d2f-a765-1486c24ff880)

---

### **Explanation of Key Elements**

| **Component**                      | **Description**                                              |
| ---------------------------------- | ------------------------------------------------------------ |
| `sky130_fd_sc_hd__mux2_1`          | 2:1 multiplexer standard cell from the Sky130 library        |
| `u1`                               | Instance name (autogenerated or user-defined)                |
| `.A0(n0), .A1(n1), .S(n2), .X(n3)` | Port-to-net connections between cell ports and internal nets |
| `n0‚Äìn3`                            | Internal wires connecting RTL signals to cell ports          |

---

### **Notes**

* This is a **structural netlist**, listing the components and their interconnections.
* It is used in **place and route**, **static timing analysis**, and other backend stages.
* The simplified version generated with `-noattr` is preferred for **manual inspection** or **debugging**.


---

## **Day 2 ‚Äì Timing Libraries, Hierarchical vs Flat Synthesis, and Flop Coding Styles**

### **Lab 4 ‚Äì Introduction to `.lib` Files (Part 1)**

---

### **Introduction to Timing `.lib` Files**

The `.lib` file, also known as a **Liberty file**, contains detailed information about **timing**, **power**, and **functionality** of standard cells used during synthesis.

---

### **Understanding the Contents of a `.lib` File**

A typical `.lib` file includes key data for each standard cell, such as:

* **Timing information** (setup time, hold time, delays)
* **Power consumption** under different conditions
* **Logical functionality** of each cell
* **Pin definitions** and **input/output relationships**

This information is essential for accurate synthesis, timing analysis, and optimization.

Let me know when you're ready to go over the actual structure or syntax of a `.lib` entry.

